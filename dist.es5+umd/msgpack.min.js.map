{"version":3,"file":"msgpack.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAqB,YAAID,IAEzBD,EAAkB,YAAIC,GACvB,CATD,CASGK,MAAM,WACT,O,wBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,SAASL,EAASM,GACzC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAG3E,ECPAF,EAAwB,SAASQ,EAAKC,GAAQ,OAAOL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,EAAO,ECCtGT,EAAwB,SAASL,GACX,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,GACvD,G,0tBCJO,IAAMC,EAAa,WACbC,EAAwBC,OAAO,wBAC/BC,EAAuBD,OAAO,wBAC9BE,EAAuBF,OAAO,uBAC9BG,EAAuBH,OAAOI,OAAOC,kBACrCC,EAAuBN,OAAOI,OAAOG,kBA4B3C,SAASC,EAASC,EAAgBC,EAAgBb,GACvD,IAAMc,EAAOC,KAAKC,MAAMhB,EAAQ,YAC1BiB,EAAMjB,EACZY,EAAKM,UAAUL,EAAQC,GACvBF,EAAKM,UAAUL,EAAS,EAAGI,EAC7B,CAEO,SAASE,EAASP,EAAgBC,GACvC,IAAMO,EAASR,EAAKS,YAAYR,GAEhC,OAAGO,EAASd,GAAwBc,EAASX,EACpCW,EAGFb,OAAOa,EAChB,C,seC/CME,GACgB,oBAAZC,SAA+D,WAAxB,QAAZ,EAAO,OAAPA,cAAO,IAAPA,aAAO,EAAPA,QAASC,WAAG,eAAkB,iBAC1C,oBAAhBC,aACgB,oBAAhBC,YAEF,SAASC,EAAUC,GAKxB,IAJA,IAAMC,EAAYD,EAAIE,OAElBC,EAAa,EACbC,EAAM,EACHA,EAAMH,GAAW,CACtB,IAAI7B,EAAQ4B,EAAIK,WAAWD,KAE3B,GAA6B,IAAhB,WAARhC,GAIE,GAA6B,IAAhB,WAARA,GAEV+B,GAAc,MACT,CAEL,GAAI/B,GAAS,OAAUA,GAAS,OAE1BgC,EAAMH,EAAW,CACnB,IAAMK,EAAQN,EAAIK,WAAWD,GACJ,QAAZ,MAARE,OACDF,EACFhC,IAAkB,KAARA,IAAkB,KAAe,KAARkC,GAAiB,M,CAOxDH,GAF2B,IAAhB,WAAR/B,GAEW,EAGA,C,MAvBhB+B,G,CA2BJ,OAAOA,CACT,CA6CA,IAAMI,EAAoBb,EAA0B,IAAIG,iBAAgBW,EAC3DC,EAA0Bf,EAEhB,oBAAZC,SAA+D,WAAxB,QAAZ,EAAO,OAAPA,cAAO,IAAPA,aAAO,EAAPA,QAASC,WAAG,eAAkB,eAChE,IACA,EAHAvB,EAaSqC,GAAeH,aAAiB,EAAjBA,EAAmBI,YAJ/C,SAAgCX,EAAaY,EAAoBC,GAC/DN,EAAmBI,WAAWX,EAAKY,EAAOE,SAASD,GACrD,EANA,SAA4Bb,EAAaY,EAAoBC,GAC3DD,EAAOG,IAAIR,EAAmBS,OAAOhB,GAAMa,EAC7C,EAUO,SAASI,EAAaC,EAAmBC,EAAqBhB,GAMnE,IALA,IAAIlB,EAASkC,EACPC,EAAMnC,EAASkB,EAEfkB,EAAuB,GACzBC,EAAS,GACNrC,EAASmC,GAAK,CACnB,IAAMG,EAAQL,EAAMjC,KACpB,GAAuB,IAAV,IAARsC,GAEHF,EAAMG,KAAKD,QACN,GAAuB,MAAV,IAARA,GAAwB,CAElC,IAAME,EAA2B,GAAnBP,EAAMjC,KACpBoC,EAAMG,MAAe,GAARD,IAAiB,EAAKE,E,MAC9B,GAAuB,MAAV,IAARF,GAAwB,CAE5BE,EAA2B,GAAnBP,EAAMjC,KAApB,IACMyC,EAA2B,GAAnBR,EAAMjC,KACpBoC,EAAMG,MAAe,GAARD,IAAiB,GAAOE,GAAS,EAAKC,E,MAC9C,GAAuB,MAAV,IAARH,GAAwB,CAElC,IAGII,GAAiB,EAARJ,IAAiB,IAHxBE,EAA2B,GAAnBP,EAAMjC,OAG4B,IAF1CyC,EAA2B,GAAnBR,EAAMjC,OAE8C,EADjC,GAAnBiC,EAAMjC,KAEhB0C,EAAO,QACTA,GAAQ,MACRN,EAAMG,KAAOG,IAAS,GAAM,KAAS,OACrCA,EAAO,MAAiB,KAAPA,GAEnBN,EAAMG,KAAKG,E,MAEXN,EAAMG,KAAKD,GAGTF,EAAMnB,QAtCK,OAuCboB,GAAUM,OAAOC,aAAY,MAAnBD,OAAM,OAAiBP,IAAK,IACtCA,EAAMnB,OAAS,E,CAQnB,OAJImB,EAAMnB,OAAS,IACjBoB,GAAUM,OAAOC,aAAY,MAAnBD,OAAM,OAAiBP,IAAK,KAGjCC,CACT,CAEA,I,EAAMQ,EAAoBpC,EAA0B,IAAII,YAAgB,KAC3DiC,EAA0BrC,EAEhB,oBAAZC,SAA8D,WAAvB,QAAZ,EAAO,OAAPA,cAAO,IAAPA,aAAO,EAAPA,QAASC,WAAG,eAAiB,cAC/D,IACA,EAHAvB,EC9JJ,EACE,SAAqB2D,EAAuBC,GAAvB,KAAAD,KAAAA,EAAuB,KAAAC,KAAAA,CAAmB,E,mcCJjE,cACE,WAAYC,GAAZ,MACE,YAAMA,IAAQ,KAGRC,EAAsC1E,OAAO2E,OAAOC,EAAYtE,W,OACtEN,OAAO6E,eAAe,EAAMH,GAE5B1E,OAAOC,eAAe,EAAM,OAAQ,CAClC6E,cAAc,EACd5E,YAAY,EACZS,MAAOiE,EAAYG,O,CAEvB,CACF,OAdiC,OAcjC,EAdA,CAAiCC,OCIpBC,GAAiB,EAUvB,SAASC,EAA0B,G,IAwBhC3D,EAxBkC4D,EAAG,MAAEC,EAAI,OACnD,GAAID,GAAO,GAAKC,GAAQ,GAAKD,GAHH,YAG+B,CAEvD,GAAa,IAATC,GAAcD,GANM,WAMsB,CAE5C,IAAME,EAAK,IAAIC,WAAW,GAG1B,OAFM/D,EAAO,IAAIgE,SAASF,EAAGG,SACxB3D,UAAU,EAAGsD,GACXE,C,CAGP,IAAMI,EAAUN,EAAM,WAChBO,EAAe,WAANP,EAOf,OANME,EAAK,IAAIC,WAAW,IACpB/D,EAAO,IAAIgE,SAASF,EAAGG,SAExB3D,UAAU,EAAIuD,GAAQ,EAAgB,EAAVK,GAEjClE,EAAKM,UAAU,EAAG6D,GACXL,C,CAQT,OAJMA,EAAK,IAAIC,WAAW,KACpB/D,EAAO,IAAIgE,SAASF,EAAGG,SACxB3D,UAAU,EAAGuD,GAClB9D,EAASC,EAAM,EAAG4D,GACXE,CAEX,CAEO,SAASM,EAAqBC,GACnC,IAAMC,EAAOD,EAAKE,UACZX,EAAMzD,KAAKC,MAAMkE,EAAO,KACxBT,EAA4B,KAApBS,EAAa,IAANV,GAGfY,EAAYrE,KAAKC,MAAMyD,EAAO,KACpC,MAAO,CACLD,IAAKA,EAAMY,EACXX,KAAMA,EAAmB,IAAZW,EAEjB,CAEO,SAASC,EAAyBC,GACvC,OAAIA,aAAkBC,KAEbhB,EADUS,EAAqBM,IAG/B,IAEX,CAEO,SAASE,EAA0B3B,GACxC,IAAMjD,EAAO,IAAIgE,SAASf,EAAKgB,OAAQhB,EAAK4B,WAAY5B,EAAK9B,YAG7D,OAAQ8B,EAAK9B,YACX,KAAK,EAIH,MAAO,CAAEyC,IAFG5D,EAAK8E,UAAU,GAEbjB,KADD,GAGf,KAAK,EAEH,IAAMkB,EAAoB/E,EAAK8E,UAAU,GAIzC,MAAO,CAAElB,IAF+B,YAAP,EAApBmB,GADI/E,EAAK8E,UAAU,GAGlBjB,KADDkB,IAAsB,GAGrC,KAAK,GAKH,MAAO,CAAEnB,IAFGrD,EAASP,EAAM,GAEb6D,KADD7D,EAAK8E,UAAU,IAG9B,QACE,MAAM,IAAIzB,EAAY,uEAAgEJ,EAAK/B,SAEjG,CAEO,SAAS8D,EAAyB/B,GACvC,IAAMgC,EAAWL,EAA0B3B,GAC3C,OAAO,IAAI0B,KAAoB,IAAfM,EAASrB,IAAYqB,EAASpB,KAAO,IACvD,CAEO,IAAMqB,EAAqB,CAChClC,KAAMU,EACN1B,OAAQyC,EACRU,OAAQH,GCrFV,aAgBE,aAPiB,KAAAI,gBAA+E,GAC/E,KAAAC,gBAA+E,GAG/E,KAAAC,SAAwE,GACxE,KAAAC,SAAwE,GAGvFnH,KAAKoH,SAASN,EAChB,CAgEF,OA9DS,YAAAM,SAAP,SAAgB,G,IACdxC,EAAI,OACJhB,EAAM,SACNmD,EAAM,SAMN,GAAInC,GAAQ,EAEV5E,KAAKkH,SAAStC,GAAQhB,EACtB5D,KAAKmH,SAASvC,GAAQmC,MACjB,CAEL,IAAMM,EAAQ,EAAIzC,EAClB5E,KAAKgH,gBAAgBK,GAASzD,EAC9B5D,KAAKiH,gBAAgBI,GAASN,C,CAElC,EAEO,YAAAO,YAAP,SAAmBhB,EAAiBiB,GAElC,IAAK,IAAIC,EAAI,EAAGA,EAAIxH,KAAKgH,gBAAgBlE,OAAQ0E,IAE/C,GAAiB,OADXC,EAAYzH,KAAKgH,gBAAgBQ,KAGzB,OADN3C,EAAO4C,EAAUnB,EAAQiB,IAG7B,OAAO,IAAIG,GADG,EAAIF,EACO3C,GAM/B,IAAS2C,EAAI,EAAGA,EAAIxH,KAAKkH,SAASpE,OAAQ0E,IAAK,CAC7C,IAAMC,EAEE5C,EADR,GAAiB,OADX4C,EAAYzH,KAAKkH,SAASM,KAGlB,OADN3C,EAAO4C,EAAUnB,EAAQiB,IAG7B,OAAO,IAAIG,EADEF,EACY3C,E,CAK/B,OAAIyB,aAAkBoB,EAEbpB,EAEF,IACT,EAEO,YAAAS,OAAP,SAAclC,EAAkBD,EAAc2C,GAC5C,IAAMI,EAAY/C,EAAO,EAAI5E,KAAKiH,iBAAiB,EAAIrC,GAAQ5E,KAAKmH,SAASvC,GAC7E,OAAI+C,EACKA,EAAU9C,EAAMD,EAAM2C,GAGtB,IAAIG,EAAQ9C,EAAMC,EAE7B,EAhFuB,EAAA+C,aAA8C,IAAIC,EAiF3E,C,CAlFA,GCrBO,SAASC,EAAiBjC,GAC/B,OAAIA,aAAkBF,WACbE,EACEkC,YAAYC,OAAOnC,GACrB,IAAIF,WAAWE,EAAOA,OAAQA,EAAOY,WAAYZ,EAAO9C,YACtD8C,aAAkBkC,YACpB,IAAIpC,WAAWE,GAGfF,WAAWsC,KAAKpC,EAE3B,C,gTCFA,aAKE,WACmBqC,EACAX,EACAY,EACAC,EACAC,EACAC,EACAC,EACAC,QAPA,IAAAN,IAAAA,EAAkDL,EAAeD,mBACjE,IAAAL,IAAAA,OAAuBnE,QACvB,IAAA+E,IAAAA,EAXY,UAYZ,IAAAC,IAAAA,EAXsB,WAYtB,IAAAC,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,GAPA,KAAAN,eAAAA,EACA,KAAAX,QAAAA,EACA,KAAAY,SAAAA,EACA,KAAAC,kBAAAA,EACA,KAAAC,SAAAA,EACA,KAAAC,aAAAA,EACA,KAAAC,gBAAAA,EACA,KAAAC,oBAAAA,EAZX,KAAAxF,IAAM,EACN,KAAApB,KAAO,IAAIgE,SAAS,IAAImC,YAAY/H,KAAKoI,oBACzC,KAAAtE,MAAQ,IAAI6B,WAAW3F,KAAK4B,KAAKiE,OAWtC,CA+aL,OA7aU,YAAA4C,kBAAR,WACEzI,KAAKgD,IAAM,CACb,EAOO,YAAA0F,gBAAP,SAAuBpC,GAGrB,OAFAtG,KAAKyI,oBACLzI,KAAK2I,SAASrC,EAAQ,GACftG,KAAK8D,MAAMJ,SAAS,EAAG1D,KAAKgD,IACrC,EAKO,YAAAY,OAAP,SAAc0C,GAGZ,OAFAtG,KAAKyI,oBACLzI,KAAK2I,SAASrC,EAAQ,GACftG,KAAK8D,MAAM8E,MAAM,EAAG5I,KAAKgD,IAClC,EAEQ,YAAA2F,SAAR,SAAiBrC,EAAiBuC,GAChC,GAAIA,EAAQ7I,KAAKmI,SACf,MAAM,IAAI9C,MAAM,oCAA6BwD,IAGjC,MAAVvC,EACFtG,KAAK8I,YACsB,kBAAXxC,EAChBtG,KAAK+I,cAAczC,GACQ,iBAAXA,EAChBtG,KAAKgJ,aAAa1C,EAAQuC,GACC,iBAAXvC,EAChBtG,KAAKiJ,aAAa3C,GACS,iBAAXA,EAChBtG,KAAKkJ,aAAa5C,GAElBtG,KAAKmJ,aAAa7C,EAAQuC,EAE9B,EAEQ,YAAAO,wBAAR,SAAgCC,GAC9B,IAAMC,EAAetJ,KAAKgD,IAAMqG,EAE5BrJ,KAAK4B,KAAKmB,WAAauG,GACzBtJ,KAAKuJ,aAA4B,EAAfD,EAEtB,EAEQ,YAAAC,aAAR,SAAqBC,GACnB,IAAMC,EAAY,IAAI1B,YAAYyB,GAC5BE,EAAW,IAAI/D,WAAW8D,GAC1BE,EAAU,IAAI/D,SAAS6D,GAE7BC,EAAS/F,IAAI3D,KAAK8D,OAElB9D,KAAK4B,KAAO+H,EACZ3J,KAAK8D,MAAQ4F,CACf,EAEQ,YAAAZ,UAAR,WACE9I,KAAK4J,QAAQ,IACf,EAEQ,YAAAb,cAAR,SAAsBzC,IACL,IAAXA,EACFtG,KAAK4J,QAAQ,KAEb5J,KAAK4J,QAAQ,IAEjB,EAEQ,YAAAZ,aAAR,SAAqB1C,EAAgBuC,GAGhCvC,GAAU,EACRA,GAAUjF,GAEXrB,KAAK4J,QAAQ,KACb5J,KAAK6J,UAAUvD,IACPA,GAAUpF,GAElBlB,KAAK4J,QAAQ,KACb5J,KAAK8J,UAAUxD,IAEftG,KAAKmJ,aAAa7C,EAAQuC,GAGzBvC,GAAUlF,GAEXpB,KAAK4J,QAAQ,KACb5J,KAAK6J,UAAUvD,IAEftG,KAAKmJ,aAAa7C,EAAQuC,EAGhC,EAEQ,YAAAI,aAAR,SAAqB3C,GACf/E,OAAOwI,cAAczD,KAAYtG,KAAKwI,oBACpClC,GAAU,EACRA,EAAS,IAEXtG,KAAK4J,QAAQtD,GACJA,EAAS,KAElBtG,KAAK4J,QAAQ,KACb5J,KAAK4J,QAAQtD,IACJA,EAAS,OAElBtG,KAAK4J,QAAQ,KACb5J,KAAKgK,SAAS1D,IACLA,EAAS,YAElBtG,KAAK4J,QAAQ,KACb5J,KAAKiK,SAAS3D,KAGdtG,KAAK4J,QAAQ,KACb5J,KAAKkK,SAAS5D,IAGZA,IAAW,GAEbtG,KAAK4J,QAAQ,IAAQtD,EAAS,IACrBA,IAAW,KAEpBtG,KAAK4J,QAAQ,KACb5J,KAAKmK,QAAQ7D,IACJA,IAAW,OAEpBtG,KAAK4J,QAAQ,KACb5J,KAAKoK,SAAS9D,IACLA,IAAW,YAEpBtG,KAAK4J,QAAQ,KACb5J,KAAKqK,SAAS/D,KAGdtG,KAAK4J,QAAQ,KACb5J,KAAKsK,SAAShE,IAKdtG,KAAKsI,cAEPtI,KAAK4J,QAAQ,KACb5J,KAAKuK,SAASjE,KAGdtG,KAAK4J,QAAQ,KACb5J,KAAKwK,SAASlE,GAGpB,EAEQ,YAAAmE,kBAAR,SAA0B1H,GACxB,GAAIA,EAAa,GAEf/C,KAAK4J,QAAQ,IAAO7G,QACf,GAAIA,EAAa,IAEtB/C,KAAK4J,QAAQ,KACb5J,KAAK4J,QAAQ7G,QACR,GAAIA,EAAa,MAEtB/C,KAAK4J,QAAQ,KACb5J,KAAKgK,SAASjH,OACT,MAAIA,EAAa,YAKtB,MAAM,IAAIsC,MAAM,2BAAoBtC,EAAU,oBAH9C/C,KAAK4J,QAAQ,KACb5J,KAAKiK,SAASlH,E,CAIlB,EAEQ,YAAAmG,aAAR,SAAqB5C,GAInB,GAFkBA,EAAOxD,OAETO,EAAwB,CACtC,IAAMN,EAAaJ,EAAU2D,GAC7BtG,KAAKoJ,wBALe,EAKyBrG,GAC7C/C,KAAKyK,kBAAkB1H,GACvBO,EAAagD,EAAQtG,KAAK8D,MAAO9D,KAAKgD,KACtChD,KAAKgD,KAAOD,C,MAENA,EAAaJ,EAAU2D,GAC7BtG,KAAKoJ,wBAXe,EAWyBrG,GAC7C/C,KAAKyK,kBAAkB1H,GN3KtB,SAAsBH,EAAaY,EAAoBC,GAI5D,IAHA,IAAMZ,EAAYD,EAAIE,OAClBjB,EAAS4B,EACTT,EAAM,EACHA,EAAMH,GAAW,CACtB,IAAI7B,EAAQ4B,EAAIK,WAAWD,KAE3B,GAA6B,IAAhB,WAARhC,GAAL,CAIO,GAA6B,IAAhB,WAARA,GAEVwC,EAAO3B,KAAcb,GAAS,EAAK,GAAQ,QACtC,CAEL,GAAIA,GAAS,OAAUA,GAAS,OAE1BgC,EAAMH,EAAW,CACnB,IAAMK,EAAQN,EAAIK,WAAWD,GACJ,QAAZ,MAARE,OACDF,EACFhC,IAAkB,KAARA,IAAkB,KAAe,KAARkC,GAAiB,M,CAK7B,IAAhB,WAARlC,IAEHwC,EAAO3B,KAAcb,GAAS,GAAM,GAAQ,IAC5CwC,EAAO3B,KAAcb,GAAS,EAAK,GAAQ,MAG3CwC,EAAO3B,KAAcb,GAAS,GAAM,EAAQ,IAC5CwC,EAAO3B,KAAcb,GAAS,GAAM,GAAQ,IAC5CwC,EAAO3B,KAAcb,GAAS,EAAK,GAAQ,I,CAI/CwC,EAAO3B,KAAqB,GAARb,EAAgB,G,MA9BlCwC,EAAO3B,KAAYb,C,CAgCzB,CMmIM0J,CAAapE,EAAQtG,KAAK8D,MAAO9D,KAAKgD,KACtChD,KAAKgD,KAAOD,CAEhB,EAEQ,YAAAoG,aAAR,SAAqB7C,EAAiBuC,GAEpC,IAAM8B,EAAM3K,KAAKkI,eAAeZ,YAAYhB,EAAQtG,KAAKuH,SACzD,GAAW,MAAPoD,EACF3K,KAAK4K,gBAAgBD,QAChB,GAAIE,MAAMC,QAAQxE,GACvBtG,KAAK+K,YAAYzE,EAAQuC,QACpB,GAAId,YAAYC,OAAO1B,GAC5BtG,KAAKgL,aAAa1E,OACb,IAAsB,iBAAXA,EAIhB,MAAM,IAAIjB,MAAM,+BAAwBhF,OAAOM,UAAUsK,SAASC,MAAM5E,KAHxEtG,KAAKmL,UAAU7E,EAAmCuC,E,CAKtD,EAEQ,YAAAmC,aAAR,SAAqB1E,GACnB,IAAM8E,EAAO9E,EAAOvD,WACpB,GAAIqI,EAAO,IAETpL,KAAK4J,QAAQ,KACb5J,KAAK4J,QAAQwB,QACR,GAAIA,EAAO,MAEhBpL,KAAK4J,QAAQ,KACb5J,KAAKgK,SAASoB,OACT,MAAIA,EAAO,YAKhB,MAAM,IAAI/F,MAAM,4BAAqB+F,IAHrCpL,KAAK4J,QAAQ,KACb5J,KAAKiK,SAASmB,E,CAIhB,IAAMtH,EAAQgE,EAAiBxB,GAC/BtG,KAAKqL,SAASvH,EAChB,EAEQ,YAAAiH,YAAR,SAAoBzE,EAAwBuC,G,QACpCuC,EAAO9E,EAAOxD,OACpB,GAAIsI,EAAO,GAETpL,KAAK4J,QAAQ,IAAOwB,QACf,GAAIA,EAAO,MAEhBpL,KAAK4J,QAAQ,KACb5J,KAAKgK,SAASoB,OACT,MAAIA,EAAO,YAKhB,MAAM,IAAI/F,MAAM,2BAAoB+F,IAHpCpL,KAAK4J,QAAQ,KACb5J,KAAKiK,SAASmB,E,KAIhB,IAAmB,QAAA9E,GAAM,8BAAE,CAAtB,IAAMgF,EAAI,QACbtL,KAAK2I,SAAS2C,EAAMzC,EAAQ,E,mGAEhC,EAEQ,YAAA0C,sBAAR,SAA8BjF,EAAiCkF,G,QACzDC,EAAQ,E,IAEZ,IAAkB,QAAAD,GAAI,mCACApI,IAAhBkD,EADQ,UAEVmF,G,kGAIJ,OAAOA,CACT,EAEQ,YAAAN,UAAR,SAAkB7E,EAAiCuC,G,QAC3C2C,EAAOnL,OAAOmL,KAAKlF,GACrBtG,KAAKqI,UACPmD,EAAKE,OAGP,IAAMN,EAAOpL,KAAKuI,gBAAkBvI,KAAKuL,sBAAsBjF,EAAQkF,GAAQA,EAAK1I,OAEpF,GAAIsI,EAAO,GAETpL,KAAK4J,QAAQ,IAAOwB,QACf,GAAIA,EAAO,MAEhBpL,KAAK4J,QAAQ,KACb5J,KAAKgK,SAASoB,OACT,MAAIA,EAAO,YAKhB,MAAM,IAAI/F,MAAM,gCAAyB+F,IAHzCpL,KAAK4J,QAAQ,KACb5J,KAAKiK,SAASmB,E,KAKhB,IAAkB,QAAAI,GAAI,8BAAE,CAAnB,IAAMrL,EAAG,QACNa,EAAQsF,EAAOnG,GAEfH,KAAKuI,sBAA6BnF,IAAVpC,IAC5BhB,KAAKkJ,aAAa/I,GAClBH,KAAK2I,SAAS3H,EAAO6H,EAAQ,G,mGAGnC,EAEQ,YAAA+B,gBAAR,SAAwBD,GACtB,IAAMS,EAAOT,EAAI9F,KAAK/B,OACtB,GAAa,IAATsI,EAEFpL,KAAK4J,QAAQ,UACR,GAAa,IAATwB,EAETpL,KAAK4J,QAAQ,UACR,GAAa,IAATwB,EAETpL,KAAK4J,QAAQ,UACR,GAAa,IAATwB,EAETpL,KAAK4J,QAAQ,UACR,GAAa,KAATwB,EAETpL,KAAK4J,QAAQ,UACR,GAAIwB,EAAO,IAEhBpL,KAAK4J,QAAQ,KACb5J,KAAK4J,QAAQwB,QACR,GAAIA,EAAO,MAEhBpL,KAAK4J,QAAQ,KACb5J,KAAKgK,SAASoB,OACT,MAAIA,EAAO,YAKhB,MAAM,IAAI/F,MAAM,sCAA+B+F,IAH/CpL,KAAK4J,QAAQ,KACb5J,KAAKiK,SAASmB,E,CAIhBpL,KAAKmK,QAAQQ,EAAI/F,MACjB5E,KAAKqL,SAASV,EAAI9F,KACpB,EAEQ,YAAA+E,QAAR,SAAgB5I,GACdhB,KAAKoJ,wBAAwB,GAE7BpJ,KAAK4B,KAAK+J,SAAS3L,KAAKgD,IAAKhC,GAC7BhB,KAAKgD,KACP,EAEQ,YAAAqI,SAAR,SAAiBO,GACf,IAAMR,EAAOQ,EAAO9I,OACpB9C,KAAKoJ,wBAAwBgC,GAE7BpL,KAAK8D,MAAMH,IAAIiI,EAAQ5L,KAAKgD,KAC5BhD,KAAKgD,KAAOoI,CACd,EAEQ,YAAAjB,QAAR,SAAgBnJ,GACdhB,KAAKoJ,wBAAwB,GAE7BpJ,KAAK4B,KAAKiK,QAAQ7L,KAAKgD,IAAKhC,GAC5BhB,KAAKgD,KACP,EAEQ,YAAAgH,SAAR,SAAiBhJ,GACfhB,KAAKoJ,wBAAwB,GAE7BpJ,KAAK4B,KAAKkK,UAAU9L,KAAKgD,IAAKhC,GAC9BhB,KAAKgD,KAAO,CACd,EAEQ,YAAAoH,SAAR,SAAiBpJ,GACfhB,KAAKoJ,wBAAwB,GAE7BpJ,KAAK4B,KAAKmK,SAAS/L,KAAKgD,IAAKhC,GAC7BhB,KAAKgD,KAAO,CACd,EAEQ,YAAAiH,SAAR,SAAiBjJ,GACfhB,KAAKoJ,wBAAwB,GAE7BpJ,KAAK4B,KAAKM,UAAUlC,KAAKgD,IAAKhC,GAC9BhB,KAAKgD,KAAO,CACd,EAEQ,YAAAqH,SAAR,SAAiBrJ,GACfhB,KAAKoJ,wBAAwB,GAE7BpJ,KAAK4B,KAAKoK,SAAShM,KAAKgD,IAAKhC,GAC7BhB,KAAKgD,KAAO,CACd,EAEQ,YAAAuH,SAAR,SAAiBvJ,GACfhB,KAAKoJ,wBAAwB,GAC7BpJ,KAAK4B,KAAKqK,WAAWjM,KAAKgD,IAAKhC,GAC/BhB,KAAKgD,KAAO,CACd,EAEQ,YAAAwH,SAAR,SAAiBxJ,GACfhB,KAAKoJ,wBAAwB,GAC7BpJ,KAAK4B,KAAKsK,WAAWlM,KAAKgD,IAAKhC,GAC/BhB,KAAKgD,KAAO,CACd,EAEQ,YAAA8G,UAAR,SAAkB9I,GAChBhB,KAAKoJ,wBAAwB,GP3Z1B,SAAoBxH,EAAgBC,EAAgBb,GACzDY,EAAKuK,aAAatK,EAAQb,EAC5B,CO2ZIoL,CAAWpM,KAAK4B,KAAM5B,KAAKgD,IAAKhC,GAChChB,KAAKgD,KAAO,CACd,EAEQ,YAAA6G,UAAR,SAAkB7I,GAChBhB,KAAKoJ,wBAAwB,GP9Z1B,SAAmBxH,EAAgBC,EAAgBb,GACxDY,EAAKyK,YAAYxK,EAAQb,EAC3B,CO8ZIsL,CAAUtM,KAAK4B,KAAM5B,KAAKgD,IAAKhC,GAC/BhB,KAAKgD,KAAO,CACd,EAEQ,YAAAkH,SAAR,SAAiBlJ,GACfhB,KAAKoJ,wBAAwB,GP/Z1B,SAAmBxH,EAAgBC,EAAgBb,GAExD,IAAMc,EAAOd,EAAQ,WACfiB,EAAMjB,EACZY,EAAKM,UAAUL,EAAQC,GACvBF,EAAKM,UAAUL,EAAS,EAAGI,EAC7B,CO2ZIsK,CAAUvM,KAAK4B,KAAM5B,KAAKgD,IAAKhC,GAC/BhB,KAAKgD,KAAO,CACd,EAEQ,YAAAsH,SAAR,SAAiBtJ,GACfhB,KAAKoJ,wBAAwB,GAE7BzH,EAAS3B,KAAK4B,KAAM5B,KAAKgD,IAAKhC,GAC9BhB,KAAKgD,KAAO,CACd,EACF,EA7bA,GCgDMwJ,EAAsC,CAAC,EAQtC,SAAS5I,EACd5C,EACAyL,GAYA,YAZA,IAAAA,IAAAA,EAAsDD,GAEtC,IAAIE,EAClBD,EAAQvE,eACPuE,EAA8ClF,QAC/CkF,EAAQtE,SACRsE,EAAQrE,kBACRqE,EAAQpE,SACRoE,EAAQnE,aACRmE,EAAQlE,gBACRkE,EAAQjE,qBAEKE,gBAAgB1H,EACjC,CChFO,SAAS2L,EAAWC,GACzB,MAAO,UAAGA,EAAO,EAAI,IAAM,GAAE,aAAK7K,KAAK8K,IAAID,GAAM3B,SAAS,IAAI6B,SAAS,EAAG,KAC5E,C,ICYA,aAKE,WAAqBC,EAAgDC,QAAhD,IAAAD,IAAAA,EAjBQ,SAiBwC,IAAAC,IAAAA,EAhBpC,IAgBZ,KAAAD,aAAAA,EAAgD,KAAAC,gBAAAA,EAJrE,KAAAC,IAAM,EACN,KAAAC,KAAO,EAMLlN,KAAKmN,OAAS,GACd,IAAK,IAAI3F,EAAI,EAAGA,EAAIxH,KAAK+M,aAAcvF,IACrCxH,KAAKmN,OAAO/I,KAAK,GAErB,CAiDF,OA/CS,YAAAgJ,YAAP,SAAmBrK,GACjB,OAAOA,EAAa,GAAKA,GAAc/C,KAAK+M,YAC9C,EAEQ,YAAAM,KAAR,SAAavJ,EAAmBC,EAAqBhB,G,QAC7CuK,EAAUtN,KAAKmN,OAAOpK,EAAa,G,IAEzCwK,EAAY,IAAqB,M,ySAAA,CAAAD,GAAO,8BAAE,CAGxC,IAHe,IAAME,EAAM,QACrBC,EAAcD,EAAO1J,MAElB4J,EAAI,EAAGA,EAAI3K,EAAY2K,IAC9B,GAAID,EAAYC,KAAO5J,EAAMC,EAAc2J,GACzC,SAASH,EAGb,OAAOC,EAAO5K,G,mGAEhB,OAAO,IACT,EAEQ,YAAA+K,MAAR,SAAc7J,EAAmB9C,GAC/B,IAAMsM,EAAUtN,KAAKmN,OAAOrJ,EAAMhB,OAAS,GACrC0K,EAAyB,CAAE1J,MAAK,EAAElB,IAAK5B,GAEzCsM,EAAQxK,QAAU9C,KAAKgN,gBAGzBM,EAASvL,KAAK6L,SAAWN,EAAQxK,OAAU,GAAK0K,EAEhDF,EAAQlJ,KAAKoJ,EAEjB,EAEO,YAAAzG,OAAP,SAAcjD,EAAmBC,EAAqBhB,GACpD,IAAM8K,EAAc7N,KAAKqN,KAAKvJ,EAAOC,EAAahB,GAClD,GAAmB,MAAf8K,EAEF,OADA7N,KAAKiN,MACEY,EAET7N,KAAKkN,OAEL,IAAMtK,EAAMiB,EAAaC,EAAOC,EAAahB,GAEvC+K,EAAoBnI,WAAWhF,UAAUiI,MAAM/H,KAAKiD,EAAOC,EAAaA,EAAchB,GAE5F,OADA/C,KAAK2N,MAAMG,EAAmBlL,GACvBA,CACT,EACF,EA7DA,G,qpEC2BMmL,EAAa,IAAInI,SAAS,IAAImC,YAAY,IAC1CiG,EAAc,IAAIrI,WAAWoI,EAAWlI,QAIjCoI,EAA8C,WACzD,IAGEF,EAAWG,QAAQ,E,CACnB,MAAOC,GACP,OAAOA,EAAEC,W,CAEX,MAAM,IAAI/I,MAAM,gBACjB,CAT0D,GAWrDgJ,EAAY,IAAIJ,EAA8B,qBAE9CK,EAAyB,IAAIC,EAEnC,aASE,WACmBrG,EACAX,EACAiH,EACAC,EACAC,EACAC,EACAC,EACAC,QAPA,IAAA3G,IAAAA,EAAkDL,EAAeD,mBACjE,IAAAL,IAAAA,OAAuBnE,QACvB,IAAAoL,IAAAA,EAAevN,QACf,IAAAwN,IAAAA,EAAexN,QACf,IAAAyN,IAAAA,EAAiBzN,QACjB,IAAA0N,IAAAA,EAAe1N,QACf,IAAA2N,IAAAA,EAAe3N,QACf,IAAA4N,IAAAA,EAAA,GAPA,KAAA3G,eAAAA,EACA,KAAAX,QAAAA,EACA,KAAAiH,aAAAA,EACA,KAAAC,aAAAA,EACA,KAAAC,eAAAA,EACA,KAAAC,aAAAA,EACA,KAAAC,aAAAA,EACA,KAAAC,WAAAA,EAhBX,KAAAC,SAAW,EACX,KAAA9L,IAAM,EAEN,KAAApB,KAAOmM,EACP,KAAAjK,MAAQkK,EACR,KAAAe,UA5BiB,EA6BR,KAAAC,MAA2B,EAWzC,CAmiBL,OAjiBU,YAAAvG,kBAAR,WACEzI,KAAK8O,SAAW,EAChB9O,KAAK+O,UA5CkB,EA6CvB/O,KAAKgP,MAAMlM,OAAS,CAGtB,EAEQ,YAAAmM,UAAR,SAAkBpJ,GAChB7F,KAAK8D,MAAQgE,EAAiBjC,GAC9B7F,KAAK4B,KL9EF,SAAwBiE,GAC7B,GAAIA,aAAkBkC,YACpB,OAAO,IAAInC,SAASC,GAGtB,IAAMqJ,EAAapH,EAAiBjC,GACpC,OAAO,IAAID,SAASsJ,EAAWrJ,OAAQqJ,EAAWzI,WAAYyI,EAAWnM,WAC3E,CKuEgBoM,CAAenP,KAAK8D,OAChC9D,KAAKgD,IAAM,CACb,EAEQ,YAAAoM,aAAR,SAAqBvJ,GACnB,IAzDuB,IAyDnB7F,KAAK+O,UAAoC/O,KAAKqP,aAAa,GAExD,CACL,IAAMC,EAAgBtP,KAAK8D,MAAMJ,SAAS1D,KAAKgD,KACzCuM,EAAUzH,EAAiBjC,GAG3B4D,EAAY,IAAI9D,WAAW2J,EAAcxM,OAASyM,EAAQzM,QAChE2G,EAAU9F,IAAI2L,GACd7F,EAAU9F,IAAI4L,EAASD,EAAcxM,QACrC9C,KAAKiP,UAAUxF,E,MATfzJ,KAAKiP,UAAUpJ,EAWnB,EAEQ,YAAAwJ,aAAR,SAAqBjE,GACnB,OAAOpL,KAAK4B,KAAKmB,WAAa/C,KAAKgD,KAAOoI,CAC5C,EAEQ,YAAAoE,qBAAR,SAA6BC,GACrB,IAAE7N,EAAc5B,KAAV,KAAEgD,EAAQhD,KAAL,IACjB,OAAO,IAAI0P,WAAW,gBAAS9N,EAAKmB,WAAaC,EAAG,eAAOpB,EAAKmB,WAAU,oCAA4B0M,EAAS,KACjH,EAMO,YAAA1I,OAAP,SAAclB,GACZ7F,KAAKyI,oBACLzI,KAAKiP,UAAUpJ,GAEf,IAAMS,EAAStG,KAAK2P,eACpB,GAAI3P,KAAKqP,aAAa,GACpB,MAAMrP,KAAKwP,qBAAqBxP,KAAKgD,KAEvC,OAAOsD,CACT,EAEQ,YAAAsJ,YAAR,SAAoB/J,G,kDAClB7F,KAAKyI,oBACLzI,KAAKiP,UAAUpJ,G,wBAER7F,KAAKqP,aAAa,GACvB,GAAMrP,KAAK2P,gBADc,M,cACzB,S,4BAIS,YAAAE,YAAb,SAAyBC,G,8HACnBC,GAAU,E,yCAEa,IAAAD,G,4EACzB,GADejK,EAAM,QACjBkK,EACF,MAAM/P,KAAKwP,qBAAqBxP,KAAK8O,UAGvC9O,KAAKoP,aAAavJ,GAElB,IACES,EAAStG,KAAK2P,eACdI,GAAU,C,CACV,MAAO5B,GACP,KAAMA,aAAaF,GACjB,MAAME,C,CAIVnO,KAAK8O,UAAY9O,KAAKgD,I,6RAGxB,GAAI+M,EAAS,CACX,GAAI/P,KAAKqP,aAAa,GACpB,MAAMrP,KAAKwP,qBAAqBxP,KAAK8O,UAEvC,MAAO,CAAP,EAAOxI,E,CAIT,MADQyI,GAAF,EAA8B/O,MAApB,SAAEgD,EAAG,MAAE8L,EAAQ,WACzB,IAAIY,WACR,uCAAgC/C,EAAWoC,GAAS,eAAOD,EAAQ,aAAK9L,EAAG,4B,yRAIxE,YAAAgN,kBAAP,SACEF,GAEA,OAAO9P,KAAKiQ,iBAAiBH,GAAQ,EACvC,EAEO,YAAAI,aAAP,SAAoBJ,GAClB,OAAO9P,KAAKiQ,iBAAiBH,GAAQ,EACvC,EAEe,YAAAG,iBAAf,SAAgCH,EAAyDhF,G,4GACnFqF,EAAwBrF,EACxBsF,GAAkB,E,2CAEK,IAAAN,G,gFACzB,GADejK,EAAM,QACjBiF,GAA8B,IAAnBsF,EACb,MAAMpQ,KAAKwP,qBAAqBxP,KAAK8O,UAGvC9O,KAAKoP,aAAavJ,GAEdsK,IACFC,EAAiBpQ,KAAKqQ,gBACtBF,GAAwB,EACxBnQ,KAAKsQ,Y,oEAKGtQ,KAAK2P,iB,OAAX,mB,OACA,OADA,SACyB,KAAnBS,EACJ,M,iCAIJ,M,sBAAmBnC,GACjB,MAAM,E,qBAIVjO,KAAK8O,UAAY9O,KAAKgD,I,4TAIlB,YAAA2M,aAAR,WACEY,EAAQ,OAAa,CACnB,IAAMxB,EAAW/O,KAAKwQ,eAClBlK,OAAM,EAEV,GAAIyI,GAAY,IAEdzI,EAASyI,EAAW,SACf,GAAIA,EAAW,IACpB,GAAIA,EAAW,IAEbzI,EAASyI,OACJ,GAAIA,EAAW,IAAM,CAG1B,GAAa,IADP3D,EAAO2D,EAAW,KACR,CACd/O,KAAKyQ,aAAarF,GAClBpL,KAAKsQ,WACL,SAASC,C,CAETjK,EAAS,CAAC,C,MAEP,GAAIyI,EAAW,IAAM,CAG1B,GAAa,IADP3D,EAAO2D,EAAW,KACR,CACd/O,KAAK0Q,eAAetF,GACpBpL,KAAKsQ,WACL,SAASC,C,CAETjK,EAAS,E,KAEN,CAEL,IAAMvD,EAAagM,EAAW,IAC9BzI,EAAStG,KAAK2Q,iBAAiB5N,EAAY,E,MAExC,GAAiB,MAAbgM,EAETzI,EAAS,UACJ,GAAiB,MAAbyI,EAETzI,GAAS,OACJ,GAAiB,MAAbyI,EAETzI,GAAS,OACJ,GAAiB,MAAbyI,EAETzI,EAAStG,KAAK4Q,eACT,GAAiB,MAAb7B,EAETzI,EAAStG,KAAK6Q,eACT,GAAiB,MAAb9B,EAETzI,EAAStG,KAAK8Q,cACT,GAAiB,MAAb/B,EAETzI,EAAStG,KAAK+Q,eACT,GAAiB,MAAbhC,EAETzI,EAAStG,KAAKgR,eACT,GAAiB,MAAbjC,EAETzI,EAAStG,KAAKiR,eACT,GAAiB,MAAblC,EAETzI,EAAStG,KAAKkR,cACT,GAAiB,MAAbnC,EAETzI,EAAStG,KAAKmR,eACT,GAAiB,MAAbpC,EAETzI,EAAStG,KAAKoR,eACT,GAAiB,MAAbrC,EAETzI,EAAStG,KAAKqR,eACT,GAAiB,MAAbtC,EAEHhM,EAAa/C,KAAKsR,SACxBhL,EAAStG,KAAK2Q,iBAAiB5N,EAAY,QACtC,GAAiB,MAAbgM,EAEHhM,EAAa/C,KAAKuR,UACxBjL,EAAStG,KAAK2Q,iBAAiB5N,EAAY,QACtC,GAAiB,MAAbgM,EAEHhM,EAAa/C,KAAKwR,UACxBlL,EAAStG,KAAK2Q,iBAAiB5N,EAAY,QACtC,GAAiB,MAAbgM,EAAmB,CAG5B,GAAa,KADP3D,EAAOpL,KAAK+Q,WACF,CACd/Q,KAAK0Q,eAAetF,GACpBpL,KAAKsQ,WACL,SAASC,C,CAETjK,EAAS,E,MAEN,GAAiB,MAAbyI,EAAmB,CAG5B,GAAa,KADP3D,EAAOpL,KAAKgR,WACF,CACdhR,KAAK0Q,eAAetF,GACpBpL,KAAKsQ,WACL,SAASC,C,CAETjK,EAAS,E,MAEN,GAAiB,MAAbyI,EAAmB,CAG5B,GAAa,KADP3D,EAAOpL,KAAK+Q,WACF,CACd/Q,KAAKyQ,aAAarF,GAClBpL,KAAKsQ,WACL,SAASC,C,CAETjK,EAAS,CAAC,C,MAEP,GAAiB,MAAbyI,EAAmB,CAG5B,GAAa,KADP3D,EAAOpL,KAAKgR,WACF,CACdhR,KAAKyQ,aAAarF,GAClBpL,KAAKsQ,WACL,SAASC,C,CAETjK,EAAS,CAAC,C,MAEP,GAAiB,MAAbyI,EAAmB,CAE5B,IAAM3D,EAAOpL,KAAKsR,SAClBhL,EAAStG,KAAKyR,aAAarG,EAAM,E,MAC5B,GAAiB,MAAb2D,EAEH3D,EAAOpL,KAAKuR,UAClBjL,EAAStG,KAAKyR,aAAarG,EAAM,QAC5B,GAAiB,MAAb2D,EAEH3D,EAAOpL,KAAKwR,UAClBlL,EAAStG,KAAKyR,aAAarG,EAAM,QAC5B,GAAiB,MAAb2D,EAETzI,EAAStG,KAAK0R,gBAAgB,EAAG,QAC5B,GAAiB,MAAb3C,EAETzI,EAAStG,KAAK0R,gBAAgB,EAAG,QAC5B,GAAiB,MAAb3C,EAETzI,EAAStG,KAAK0R,gBAAgB,EAAG,QAC5B,GAAiB,MAAb3C,EAETzI,EAAStG,KAAK0R,gBAAgB,EAAG,QAC5B,GAAiB,MAAb3C,EAETzI,EAAStG,KAAK0R,gBAAgB,GAAI,QAC7B,GAAiB,MAAb3C,EAEH3D,EAAOpL,KAAKsR,SAClBhL,EAAStG,KAAK0R,gBAAgBtG,EAAM,QAC/B,GAAiB,MAAb2D,EAEH3D,EAAOpL,KAAKuR,UAClBjL,EAAStG,KAAK0R,gBAAgBtG,EAAM,OAC/B,IAAiB,MAAb2D,EAKT,MAAM,IAAI9J,EAAY,kCAA2B0H,EAAWoC,KAHtD3D,EAAOpL,KAAKwR,UAClBlL,EAAStG,KAAK0R,gBAAgBtG,EAAM,E,CAKtCpL,KAAKsQ,WAGL,IADA,IAAMtB,EAAQhP,KAAKgP,MACZA,EAAMlM,OAAS,GAAG,CAEvB,IAAM6O,EAAQ3C,EAAMA,EAAMlM,OAAS,GACnC,GAAmB,IAAf6O,EAAM/M,KAAsB,CAG9B,GAFA+M,EAAMC,MAAMD,EAAME,UAAYvL,EAC9BqL,EAAME,WACFF,EAAME,WAAaF,EAAMvG,KAI3B,SAASmF,EAHTvB,EAAM8C,MACNxL,EAASqL,EAAMC,K,KAIZ,IAAmB,IAAfD,EAAM/M,KAAwB,CACvC,QAxYFmN,EAEa,WAFbA,SAwYyBzL,IAtYY,WAAZyL,GAAmC,UAAXA,EAuY7C,MAAM,IAAI9M,EAAY,uDAAyDqB,GAEjF,GAAe,cAAXA,EACF,MAAM,IAAIrB,EAAY,oCAGxB0M,EAAMxR,IAAMmG,EACZqL,EAAM/M,KAAO,EACb,SAAS2L,C,CAOT,GAHAoB,EAAMK,IAAIL,EAAMxR,KAAQmG,EACxBqL,EAAMM,YAEFN,EAAMM,YAAcN,EAAMvG,KAGvB,CACLuG,EAAMxR,IAAM,KACZwR,EAAM/M,KAAO,EACb,SAAS2L,C,CALTvB,EAAM8C,MACNxL,EAASqL,EAAMK,G,EASrB,OAAO1L,C,CApaa,IAClByL,CAqaN,EAEQ,YAAAvB,aAAR,WAME,OAvZuB,IAkZnBxQ,KAAK+O,WACP/O,KAAK+O,SAAW/O,KAAK8Q,UAIhB9Q,KAAK+O,QACd,EAEQ,YAAAuB,SAAR,WACEtQ,KAAK+O,UA3ZkB,CA4ZzB,EAEQ,YAAAsB,cAAR,WACE,IAAMtB,EAAW/O,KAAKwQ,eAEtB,OAAQzB,GACN,KAAK,IACH,OAAO/O,KAAK+Q,UACd,KAAK,IACH,OAAO/Q,KAAKgR,UACd,QACE,GAAIjC,EAAW,IACb,OAAOA,EAAW,IAElB,MAAM,IAAI9J,EAAY,wCAAiC0H,EAAWoC,KAI1E,EAEQ,YAAA0B,aAAR,SAAqBrF,GACnB,GAAIA,EAAOpL,KAAK2O,aACd,MAAM,IAAI1J,EAAY,2CAAoCmG,EAAI,mCAA2BpL,KAAK2O,aAAY,MAG5G3O,KAAKgP,MAAM5K,KAAK,CACdQ,KAAM,EACNwG,KAAI,EACJjL,IAAK,KACL8R,UAAW,EACXD,IAAK,CAAC,GAEV,EAEQ,YAAAtB,eAAR,SAAuBtF,GACrB,GAAIA,EAAOpL,KAAK0O,eACd,MAAM,IAAIzJ,EAAY,6CAAsCmG,EAAI,+BAAuBpL,KAAK0O,eAAc,MAG5G1O,KAAKgP,MAAM5K,KAAK,CACdQ,KAAM,EACNwG,KAAI,EACJwG,MAAO,IAAI/G,MAAeO,GAC1ByG,SAAU,GAEd,EAEQ,YAAAlB,iBAAR,SAAyB5N,EAAoBmP,G,MAC3C,GAAInP,EAAa/C,KAAKwO,aACpB,MAAM,IAAIvJ,EACR,kDAA2ClC,EAAU,6BAAqB/C,KAAKwO,aAAY,MAI/F,GAAIxO,KAAK8D,MAAMf,WAAa/C,KAAKgD,IAAMkP,EAAenP,EACpD,MAAMsL,EAGR,IACI/H,EADEzE,EAAS7B,KAAKgD,IAAMkP,EAU1B,OAPE5L,EADEtG,KAAKmS,kBAAkC,QAAf,EAAAnS,KAAK6O,kBAAU,eAAEzB,YAAYrK,IAC9C/C,KAAK6O,WAAW9H,OAAO/G,KAAK8D,MAAOjC,EAAQkB,GAC3CA,EAAa4B,EV3VrB,SAAsBb,EAAmBC,EAAqBhB,GACnE,IAAMqP,EAActO,EAAMJ,SAASK,EAAaA,EAAchB,GAC9D,OAAO2B,EAAmBqC,OAAOqL,EACnC,CUyVeC,CAAarS,KAAK8D,MAAOjC,EAAQkB,GAEjCc,EAAa7D,KAAK8D,MAAOjC,EAAQkB,GAE5C/C,KAAKgD,KAAOkP,EAAenP,EACpBuD,CACT,EAEQ,YAAA6L,cAAR,WACE,OAAInS,KAAKgP,MAAMlM,OAAS,GAEA,IADR9C,KAAKgP,MAAMhP,KAAKgP,MAAMlM,OAAS,GAChC8B,IAGjB,EAEQ,YAAA6M,aAAR,SAAqB1O,EAAoBuP,GACvC,GAAIvP,EAAa/C,KAAKyO,aACpB,MAAM,IAAIxJ,EAAY,2CAAoClC,EAAU,6BAAqB/C,KAAKyO,aAAY,MAG5G,IAAKzO,KAAKqP,aAAatM,EAAauP,GAClC,MAAMjE,EAGR,IAAMxM,EAAS7B,KAAKgD,IAAMsP,EACpBhM,EAAStG,KAAK8D,MAAMJ,SAAS7B,EAAQA,EAASkB,GAEpD,OADA/C,KAAKgD,KAAOsP,EAAavP,EAClBuD,CACT,EAEQ,YAAAoL,gBAAR,SAAwBtG,EAAckH,GACpC,GAAIlH,EAAOpL,KAAK4O,aACd,MAAM,IAAI3J,EAAY,2CAAoCmG,EAAI,6BAAqBpL,KAAK4O,aAAY,MAGtG,IAAM2D,EAAUvS,KAAK4B,KAAKsM,QAAQlO,KAAKgD,IAAMsP,GACvCzN,EAAO7E,KAAKyR,aAAarG,EAAMkH,EAAa,GAClD,OAAOtS,KAAKkI,eAAenB,OAAOlC,EAAM0N,EAASvS,KAAKuH,QACxD,EAEQ,YAAA+J,OAAR,WACE,OAAOtR,KAAK4B,KAAK4Q,SAASxS,KAAKgD,IACjC,EAEQ,YAAAuO,QAAR,WACE,OAAOvR,KAAK4B,KAAK6Q,UAAUzS,KAAKgD,IAClC,EAEQ,YAAAwO,QAAR,WACE,OAAOxR,KAAK4B,KAAK8E,UAAU1G,KAAKgD,IAClC,EAEQ,YAAA8N,OAAR,WACE,IAAM9P,EAAQhB,KAAK4B,KAAK4Q,SAASxS,KAAKgD,KAEtC,OADAhD,KAAKgD,MACEhC,CACT,EAEQ,YAAAkQ,OAAR,WACE,IAAMlQ,EAAQhB,KAAK4B,KAAKsM,QAAQlO,KAAKgD,KAErC,OADAhD,KAAKgD,MACEhC,CACT,EAEQ,YAAA+P,QAAR,WACE,IAAM/P,EAAQhB,KAAK4B,KAAK6Q,UAAUzS,KAAKgD,KAEvC,OADAhD,KAAKgD,KAAO,EACLhC,CACT,EAEQ,YAAAmQ,QAAR,WACE,IAAMnQ,EAAQhB,KAAK4B,KAAK8Q,SAAS1S,KAAKgD,KAEtC,OADAhD,KAAKgD,KAAO,EACLhC,CACT,EAEQ,YAAAgQ,QAAR,WACE,IAAMhQ,EAAQhB,KAAK4B,KAAK8E,UAAU1G,KAAKgD,KAEvC,OADAhD,KAAKgD,KAAO,EACLhC,CACT,EAEQ,YAAAoQ,QAAR,WACE,IAAMpQ,EAAQhB,KAAK4B,KAAK+Q,SAAS3S,KAAKgD,KAEtC,OADAhD,KAAKgD,KAAO,EACLhC,CACT,EAEQ,YAAAiQ,QAAR,WACE,IXxiBsBrP,EAAgBC,EAClCO,EWuiBEpB,GXxiBgBY,EWwiBE5B,KAAK4B,KXxiBSC,EWwiBH7B,KAAKgD,KXviBpCZ,EAASR,EAAKgR,aAAa/Q,IAErBJ,EACHW,EAGFb,OAAOa,IWmiBZ,OADApC,KAAKgD,KAAO,EACLhC,CACT,EAEQ,YAAAqQ,QAAR,WACE,IAAMrQ,EAAQmB,EAASnC,KAAK4B,KAAM5B,KAAKgD,KAEvC,OADAhD,KAAKgD,KAAO,EACLhC,CACT,EAEQ,YAAA4P,QAAR,WACE,IAAM5P,EAAQhB,KAAK4B,KAAKiR,WAAW7S,KAAKgD,KAExC,OADAhD,KAAKgD,KAAO,EACLhC,CACT,EAEQ,YAAA6P,QAAR,WACE,IAAM7P,EAAQhB,KAAK4B,KAAKkR,WAAW9S,KAAKgD,KAExC,OADAhD,KAAKgD,KAAO,EACLhC,CACT,EACF,EArjBA,GCnBa+R,EAAsC,CAAC,EAW7C,SAAShM,EACdlB,EACA4G,GAWA,YAXA,IAAAA,IAAAA,EAAsDsG,GAEtC,IAAIC,EAClBvG,EAAQvE,eACPuE,EAA8ClF,QAC/CkF,EAAQ+B,aACR/B,EAAQgC,aACRhC,EAAQiC,eACRjC,EAAQkC,aACRlC,EAAQmC,cAEK7H,OAAOlB,EACxB,CASO,SAAS+J,GACd/J,EACA4G,GAWA,YAXA,IAAAA,IAAAA,EAAsDsG,GAEtC,IAAIC,EAClBvG,EAAQvE,eACPuE,EAA8ClF,QAC/CkF,EAAQ+B,aACR/B,EAAQgC,aACRhC,EAAQiC,eACRjC,EAAQkC,aACRlC,EAAQmC,cAEKgB,YAAY/J,EAC7B,C,mrDC9EA,SAASoN,GAAiBjS,GACxB,GAAa,MAATA,EACF,MAAM,IAAIqE,MAAM,0DAEpB,CAmBO,SAAS6N,GAAuBC,GACrC,OA3BgD,MA2B5BA,EA3BGrS,OAAOsS,eA4BrBD,EAnBJ,SAA2CrD,G,oGAC1CuD,EAASvD,EAAOwD,Y,yDAIM,YAAMD,EAAOE,S,cAA/B,EAAkB,SAAhBC,EAAI,OAAExS,EAAK,QACfwS,E,eAAA,M,OACF,mB,cAEFP,GAAcjS,G,MACRA,I,OAAN,mB,cAAA,S,wCAGFqS,EAAOI,c,6BAQAC,CAAwBP,EAEnC,CC9BQ,SAAetD,GACrBsD,EACA1G,G,YAAA,IAAAA,IAAAA,EAAsDsG,G,imCAatD,OAXMjD,EAASoD,GAAoBC,GAW5B,CAAP,EATgB,IAAIH,EAClBvG,EAAQvE,eACPuE,EAA8ClF,QAC/CkF,EAAQ+B,aACR/B,EAAQgC,aACRhC,EAAQiC,eACRjC,EAAQkC,aACRlC,EAAQmC,cAEKiB,YAAYC,G,oSAOrB,SAASE,GACfmD,EACA1G,QAAA,IAAAA,IAAAA,EAAsDsG,GAEtD,IAAMjD,EAASoD,GAAoBC,GAYnC,OAVgB,IAAIH,EAClBvG,EAAQvE,eACPuE,EAA8ClF,QAC/CkF,EAAQ+B,aACR/B,EAAQgC,aACRhC,EAAQiC,eACRjC,EAAQkC,aACRlC,EAAQmC,cAGKoB,kBAAkBF,EACnC,CAMO,SAAS6D,GACdR,EACA1G,QAAA,IAAAA,IAAAA,EAAsDsG,GAEtD,IAAMjD,EAASoD,GAAoBC,GAYnC,OAVgB,IAAIH,EAClBvG,EAAQvE,eACPuE,EAA8ClF,QAC/CkF,EAAQ+B,aACR/B,EAAQgC,aACRhC,EAAQiC,eACRjC,EAAQkC,aACRlC,EAAQmC,cAGKsB,aAAaJ,EAC9B,CAKO,SAASI,GACdiD,EACA1G,GAEA,YAFA,IAAAA,IAAAA,EAAsDsG,GAE/CY,GAAkBR,EAAY1G,EACvC,C","sources":["webpack://MessagePack/webpack/universalModuleDefinition","webpack://MessagePack/webpack/bootstrap","webpack://MessagePack/webpack/runtime/define property getters","webpack://MessagePack/webpack/runtime/hasOwnProperty shorthand","webpack://MessagePack/webpack/runtime/make namespace object","webpack://MessagePack/./src/utils/int.ts","webpack://MessagePack/./src/utils/utf8.ts","webpack://MessagePack/./src/ExtData.ts","webpack://MessagePack/./src/DecodeError.ts","webpack://MessagePack/./src/timestamp.ts","webpack://MessagePack/./src/ExtensionCodec.ts","webpack://MessagePack/./src/utils/typedArrays.ts","webpack://MessagePack/./src/Encoder.ts","webpack://MessagePack/./src/encode.ts","webpack://MessagePack/./src/utils/prettyByte.ts","webpack://MessagePack/./src/CachedKeyDecoder.ts","webpack://MessagePack/./src/Decoder.ts","webpack://MessagePack/./src/decode.ts","webpack://MessagePack/./src/utils/stream.ts","webpack://MessagePack/./src/decodeAsync.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MessagePack\"] = factory();\n\telse\n\t\troot[\"MessagePack\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Integer Utility\n\nexport const UINT32_MAX = 0xffff_ffff;\nexport const BIGUINT64_MAX: bigint = BigInt(\"18446744073709551615\");\nexport const BIGINT64_MIN: bigint = BigInt(\"-9223372036854775808\");\nexport const BIGINT64_MAX: bigint = BigInt(\"9223372036854775807\");\nexport const BIG_MIN_SAFE_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\nexport const BIG_MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\n\nexport function isBUInt64(value: bigint) {\n  return value <= BIGUINT64_MAX;\n}\n\nexport function isBInt64(value: bigint) {\n  return value >= BIGINT64_MIN && value <= BIGINT64_MAX;\n}\n\nexport function setBUint64(view: DataView, offset: number, value: bigint): void {\n  view.setBigUint64(offset, value);\n}\n\nexport function setBInt64(view: DataView, offset: number, value: bigint): void {\n  view.setBigInt64(offset, value);\n}\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nexport function setUint64(view: DataView, offset: number, value: number): void {\n\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number): number | bigint {\n  const bigNum = view.getBigInt64(offset);\n\n  if(bigNum < BIG_MIN_SAFE_INTEGER || bigNum > BIG_MAX_SAFE_INTEGER) {\n    return bigNum;\n  }\n  \n  return Number(bigNum);\n}\n\nexport function getUint64(view: DataView, offset: number): number | bigint {\n  const bigNum = view.getBigUint64(offset);\n\n  if(bigNum > BIG_MAX_SAFE_INTEGER) {\n    return bigNum;\n  }\n  \n  return Number(bigNum);\n}\n","/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport { UINT32_MAX } from \"./int\";\n\nconst TEXT_ENCODING_AVAILABLE =\n  (typeof process === \"undefined\" || process?.env?.[\"TEXT_ENCODING\"] !== \"never\") &&\n  typeof TextEncoder !== \"undefined\" &&\n  typeof TextDecoder !== \"undefined\";\n\nexport function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\nconst sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport const TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_ENCODING\"] !== \"force\"\n  ? 200\n  : 0;\n\nfunction utf8EncodeTEencode(str: string, output: Uint8Array, outputOffset: number): void {\n  output.set(sharedTextEncoder!.encode(str), outputOffset);\n}\n\nfunction utf8EncodeTEencodeInto(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder!.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport const utf8EncodeTE = sharedTextEncoder?.encodeInto ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport const TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_DECODER\"] !== \"force\"\n  ? 200\n  : 0;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder!.decode(stringBytes);\n}\n","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  constructor(readonly type: number, readonly data: Uint8Array) {}\n}\n","export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError\";\nimport { getInt64, setInt64 } from \"./utils/int\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4) as number;\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n","// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData\";\nimport { timestampExtension } from \"./timestamp\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (input: unknown, context: ContextType) => Uint8Array | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = 1 + type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n","export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n","import { utf8EncodeJs, utf8Count, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { setInt64, setUint64, setBInt64, setBUint64, BIGINT64_MAX, BIGINT64_MIN, BIGUINT64_MAX } from \"./utils/int\";\nimport { ensureUint8Array } from \"./utils/typedArrays\";\nimport type { ExtData } from \"./ExtData\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport class Encoder<ContextType = undefined> {\n  private pos = 0;\n  private view = new DataView(new ArrayBuffer(this.initialBufferSize));\n  private bytes = new Uint8Array(this.view.buffer);\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxDepth = DEFAULT_MAX_DEPTH,\n    private readonly initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE,\n    private readonly sortKeys = false,\n    private readonly forceFloat32 = false,\n    private readonly ignoreUndefined = false,\n    private readonly forceIntegerToFloat = false,\n  ) {}\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.subarray(0, this.pos);\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.slice(0, this.pos);\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"bigint\") {\n      this.encodeBigInt(object, depth);\n    } else if (typeof object === \"number\") {\n      this.encodeNumber(object);\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n\n  private encodeBigInt(object: bigint, depth: number) {\n    //NOTE: encodeObject is used to handle numbers out of range. Someday arbitrary precision integers can be a thing.\n\n    if(object >= 0) {\n      if(object <= BIGINT64_MAX) {\n        // int 64\n        this.writeU8(0xd3);\n        this.writeBI64(object);\n      } else if(object <= BIGUINT64_MAX) {\n        // uint 64\n        this.writeU8(0xcf);\n        this.writeBU64(object);\n      } else {\n        this.encodeObject(object, depth);\n      }\n    } else {\n      if(object >= BIGINT64_MIN) {\n        // int 64\n        this.writeU8(0xd3);\n        this.writeBI64(object);\n      } else {\n        this.encodeObject(object, depth);\n      }\n    }\n  }\n\n  private encodeNumber(object: number) {\n    if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        }\n      }\n    } else {\n      // non-integer numbers\n      if (this.forceFloat32) {\n        // float 32\n        this.writeU8(0xca);\n        this.writeF32(object);\n      } else {\n        // float 64\n        this.writeU8(0xcb);\n        this.writeF64(object);\n      }\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n    const strLength = object.length;\n\n    if (strLength > TEXT_ENCODER_THRESHOLD) {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeTE(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    } else {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeJs(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    }\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBU64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    setBUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBI64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    setBInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n}\n","import { Encoder } from \"./Encoder\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec\";\nimport type { ContextOf, SplitUndefined } from \"./context\";\n\nexport type EncodeOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    sortKeys: boolean;\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst defaultEncodeOptions: EncodeOptions = {};\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType = undefined>(\n  value: unknown,\n  options: EncodeOptions<SplitUndefined<ContextType>> = defaultEncodeOptions as any,\n): Uint8Array {\n  const encoder = new Encoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxDepth,\n    options.initialBufferSize,\n    options.sortKeys,\n    options.forceFloat32,\n    options.ignoreUndefined,\n    options.forceIntegerToFloat,\n  );\n  return encoder.encodeSharedRef(value);\n}\n","export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n","import { utf8DecodeJs } from \"./utils/utf8\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n","import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\nimport { DecodeError } from \"./DecodeError\";\n\nconst enum State {\n  ARRAY,\n  MAP_KEY,\n  MAP_VALUE,\n}\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  const keyType = typeof key;\n\n  return keyType === \"string\" || keyType === \"number\" || keyType == \"bigint\";\n};\n\ntype StackMapState = {\n  type: State.MAP_KEY | State.MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: State.ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport const DataViewIndexOutOfBoundsError: typeof Error = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e: any) {\n    return e.constructor;\n  }\n  throw new Error(\"never reached\");\n})();\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: Array<StackState> = [];\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxStrLength = UINT32_MAX,\n    private readonly maxBinLength = UINT32_MAX,\n    private readonly maxArrayLength = UINT32_MAX,\n    private readonly maxMapLength = UINT32_MAX,\n    private readonly maxExtLength = UINT32_MAX,\n    private readonly keyDecoder: KeyDecoder | null = sharedCachedKeyDecoder,\n  ) {}\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0;\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | BufferSource): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | BufferSource) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | BufferSource): unknown {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    const object = this.doDecodeSync();\n    if (this.hasRemaining(1)) {\n      throw this.createExtraByteError(this.pos);\n    }\n    return object;\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    while (this.hasRemaining(1)) {\n      yield this.doDecodeSync();\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | BufferSource>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1]!;\n        if (state.type === State.ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === State.MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n          }\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = State.MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = State.MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: State.MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: State.ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(this.bytes, offset, byteLength);\n    } else {\n      object = utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1]!;\n      return state.type === State.MAP_KEY;\n    }\n    return false;\n  }\n\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number | bigint {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number | bigint {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec\";\nimport type { ContextOf, SplitUndefined } from \"./context\";\n\nexport type DecodeOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport const defaultDecodeOptions: DecodeOptions = {};\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): unknown {\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeMulti(buffer);\n}\n","// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nfunction assertNonNull<T>(value: T | null | undefined): asserts value is T {\n  if (value == null) {\n    throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n  }\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      assertNonNull(value);\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterable<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport { ensureAsyncIterable } from \"./utils/stream\";\nimport { defaultDecodeOptions } from \"./decode\";\nimport type { ReadableStreamLike } from \"./utils/stream\";\nimport type { DecodeOptions } from \"./decode\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export async function decodeAsync<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Promise<unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeAsync(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export function decodeArrayStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeArrayStream(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeStream(stream);\n}\n\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nexport function decodeStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  return decodeMultiStream(streamLike, options);\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","UINT32_MAX","BIGUINT64_MAX","BigInt","BIGINT64_MIN","BIGINT64_MAX","BIG_MIN_SAFE_INTEGER","Number","MIN_SAFE_INTEGER","BIG_MAX_SAFE_INTEGER","MAX_SAFE_INTEGER","setInt64","view","offset","high","Math","floor","low","setUint32","getInt64","bigNum","getBigInt64","TEXT_ENCODING_AVAILABLE","process","env","TextEncoder","TextDecoder","utf8Count","str","strLength","length","byteLength","pos","charCodeAt","extra","sharedTextEncoder","undefined","TEXT_ENCODER_THRESHOLD","utf8EncodeTE","encodeInto","output","outputOffset","subarray","set","encode","utf8DecodeJs","bytes","inputOffset","end","units","result","byte1","push","byte2","byte3","unit","String","fromCharCode","sharedTextDecoder","TEXT_DECODER_THRESHOLD","type","data","message","proto","create","DecodeError","setPrototypeOf","configurable","name","Error","EXT_TIMESTAMP","encodeTimeSpecToTimestamp","sec","nsec","rv","Uint8Array","DataView","buffer","secHigh","secLow","encodeDateToTimeSpec","date","msec","getTime","nsecInSec","encodeTimestampExtension","object","Date","decodeTimestampToTimeSpec","byteOffset","getUint32","nsec30AndSecHigh2","decodeTimestampExtension","timeSpec","timestampExtension","decode","builtInEncoders","builtInDecoders","encoders","decoders","register","index","tryToEncode","context","i","encodeExt","ExtData","decodeExt","defaultCodec","ExtensionCodec","ensureUint8Array","ArrayBuffer","isView","from","extensionCodec","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","reinitializeState","encodeSharedRef","doEncode","slice","depth","encodeNil","encodeBoolean","encodeBigInt","encodeNumber","encodeString","encodeObject","ensureBufferSizeToWrite","sizeToWrite","requiredSize","resizeBuffer","newSize","newBuffer","newBytes","newView","writeU8","writeBI64","writeBU64","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","writeStringHeader","utf8EncodeJs","ext","encodeExtension","Array","isArray","encodeArray","encodeBinary","toString","apply","encodeMap","size","writeU8a","item","countWithoutUndefined","keys","count","sort","setUint8","values","setInt8","setUint16","setInt16","setInt32","setFloat32","setFloat64","setBigUint64","setBUint64","setBigInt64","setBInt64","setUint64","defaultEncodeOptions","options","Encoder","prettyByte","byte","abs","padStart","maxKeyLength","maxLengthPerKey","hit","miss","caches","canBeCached","find","records","FIND_CHUNK","record","recordBytes","j","store","random","cachedValue","slicedCopyOfBytes","EMPTY_VIEW","EMPTY_BYTES","DataViewIndexOutOfBoundsError","getInt8","e","constructor","MORE_DATA","sharedCachedKeyDecoder","CachedKeyDecoder","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","totalPos","headByte","stack","setBuffer","bufferView","createDataView","appendBuffer","hasRemaining","remainingData","newData","createExtraByteError","posToShow","RangeError","doDecodeSync","decodeMulti","decodeAsync","stream","decoded","decodeArrayStream","decodeMultiAsync","decodeStream","isArrayHeaderRequired","arrayItemsLeft","readArraySize","complete","DECODE","readHeadByte","pushMapState","pushArrayState","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","state","array","position","pop","keyType","map","readCount","headerOffset","stateIsMapKey","stringBytes","utf8DecodeTD","headOffset","extType","getUint8","getUint16","getInt16","getInt32","getBigUint64","getFloat32","getFloat64","defaultDecodeOptions","Decoder","assertNonNull","ensureAsyncIterable","streamLike","asyncIterator","reader","getReader","read","done","releaseLock","asyncIterableFromStream","decodeMultiStream"],"sourceRoot":""}